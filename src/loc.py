"""Latest location-specific information."""

import numpy as n, ant, sim, fit, os, coord

class BeamNoFlaps(ant.Beam):
    """A specific beam model for the PAPER experiment.  This model is for
    a single dipole element with no flaps."""
    def __init__(self, freqs, active_chans=None, **kwargs):
        """The axes of the Cs matrices are polynomials in frequency going
        to the right, and polys in cos(2*az) going down."""
        CsAm = n.array([        # N. Gugliucci 08/07
            [ 2.3541326  ,-0.0039133512 , 1.6055088e-05,-2.7468911e-08],
            [-0.46909345 , 0.0084471178 ,-5.1260711e-05, 1.0299793e-07],
            [ 0.32753617 ,-0.0081176326 , 5.8822952e-05,-1.3303273e-07],
            [-0.046844105, 0.00076223627,-3.5474502e-06, 4.4132035e-09],
            [-0.073523813, 0.0018151892 ,-1.3435102e-05, 3.1225928e-08],
            [ 0.047340855,-0.00085097424, 4.9799933e-06,-9.5164123e-09],
        ])
        CsXo = n.array([        # N. Gugliucci 08/07
           [-121.29224, 1.9851554 ,-0.011876889  , 2.5222526e-05],
           [ 76.969303,-1.3947796 , 0.0085644354 ,-1.7448153e-05],
           [-36.638691, 0.93699466,-0.0068616164 , 1.5544311e-05],
           [ 10.189859,-0.18212180, 0.00098309486,-1.6152395e-06],
           [ 5.9997050,-0.15737420, 0.0012090764 ,-2.8862905e-06],
           [-5.6561847, 0.10468756,-0.00063126068, 1.2444705e-06],
        ])
        CsSd = n.array([        # N. Gugliucci 08/07
            [ 143.84525,-1.1088605  , 0.0048397670 ,-7.1054741e-06],
            [-104.00886, 1.9980993  ,-0.013304344  , 2.8955473e-05],
            [ 28.304230,-0.75088201 , 0.0056338561 ,-1.2898564e-05],
            [-8.7149717, 0.16108215 ,-0.00090283393, 1.5386691e-06],
            [-3.4672940, 0.091929321,-0.00071502397, 1.7311496e-06],
            [ 3.4123240,-0.063083812, 0.00038093617,-7.5356570e-07],
        ])
        mhz_freqs = 1e3 * freqs # GHz -> MHz
        mhz_freqs = n.array([
           n.ones_like(mhz_freqs),
           mhz_freqs,
           mhz_freqs**2,
           mhz_freqs**3,
        ])
        self.BAm = n.dot(CsAm, mhz_freqs)
        self.BXo = n.dot(CsXo, mhz_freqs)
        self.BSd = n.dot(CsSd, mhz_freqs)
        sim.Beam.__init__(self, freqs, active_chans)
    def select_chans(self, active_chans):
        if active_chans is None: active_chans = n.arange(self.freqs.size)
        sim.Beam.select_chans(self, active_chans)
        self.BAm_sel = self.BAm.take(active_chans, axis=1)
        self.BXo_sel = self.BXo.take(active_chans, axis=1)
        self.BSd_sel = self.BSd.take(active_chans, axis=1)
    def response(self, xyz):
        """Return the beam response across the active band for the specified
        topocentric coordinates (with z = up, x = east). 2nd axis should be 
        multiple coordinates.  Returns 'x' pol (rotate pi/2 for 'y')."""
        az,alt = coord.top2azalt(xyz)
        zang = n.pi/2 - alt
        if zang.size == 1:
            zang = n.array([zang]); zang.shape = (1,)
            az = n.array([az]); az.shape = (1,)
        a = n.array([0,2,4,6,8,10],dtype=n.float)
        a.shape = (1,) + a.shape; az.shape += (1,); zang.shape += (1,)
        a = n.cos(n.dot(az, a))
        a[:,0] = 0.5
        a1 = n.dot(a, self.BAm_sel)
        a2 = n.dot(a, self.BXo_sel)
        a3 = n.dot(a, self.BSd_sel)
        z = (180*zang/n.pi - a2) / a3
        return n.sqrt(a1 * n.exp(-z**2/2))

#  _                    _   _                 
# | |    ___   ___ __ _| |_(_) ___  _ __  ___ 
# | |   / _ \ / __/ _` | __| |/ _ \| '_ \/ __|
# | |__| (_) | (_| (_| | |_| | (_) | | | \__ \
# |_____\___/ \___\__,_|\__|_|\___/|_| |_|___/

locations = {
    'pgb220': {
        'loc': ( '38:25:59.24',  '-79:51:02.1'), # Green Bank, WV
        'antpos': 
            [[  -8.5, 455.3,   9.8],
             [ 205.3, 319.6,-250.8],
             [-262.1,-218.8, 319.6],
             [-292.3,  -7.5, 360.6],],
        'delays': [0.,  3.86,-14.51,  2.87],
        'offsets': [0., 0.07, 0.8, 0.0085],
        'amps': [3e-5, 3e-5, 3e-5, 3e-5],
        'passbands': [None, None, None, None,],
        'beam': BeamNoFlaps,
    },
    'pwa303': {
        'loc': ('-26:44:12.74', '116:39:59.33'), # Boolardy, Australia
        'antpos': 
            #[[    0.,    0.,    0.],
            # [-100.7, 139.1,-197.7],
            # [ -68.7, 383.4,-132.6],
            # [  59.4, 465.3, 120.7],],
            [[    0.,    0.,    0.],
             [-100.7, 139.1,-197.8],
             [ -68.7, 383.4,-133.0],
             [  59.4, 465.3, 120.0],],
        #'delays': [0., -1.62, -1.41, -1.67],
        'delays': [0., -1.56, -1.46, -1.72],
        #'offsets': [0., 0.16,-0.20, 0.28],
        'offsets':[0., .65, 0., -.31],
        #'amps': [3.7e-7, 3.2e-7, 3.4e-7, 3.3e-7],
        'amps': [10.0e-5,10.0e-5, 9.3e-5, 9.9e-5],
        'passbands': [None, None, None, None,],
        'beam': BeamNoFlaps,
    },
    'pgb371': {
        'loc':
            ( '38:25:59.24',  '-79:51:02.1'), # Green Bank, WV
        'antpos':
            [[   0.00,    0.00,    0.00],
             [ 214.78, -136.53, -260.37],
             #[ 196.25, -810.08, -254.34],
             [ 196.25, -810.08, -253.98],
             [-253.94, -674.41,  309.69],
             [-281.70, -463.64,  355.24],
             [-274.60, -362.10,  346.08],
             [-174.87, -102.46,  217.85],
             [ -76.55,  -20.95,   98.04]],
            #[[  -7.65, 455.45,   9.16],
            # [ 207.13, 318.92,-251.30],
            # [ 188.60,-354.63,-244.97],
            # [-261.59,-218.96, 318.93],
            # [-289.35,  -8.19, 364.48],
            # [-282.25,  93.35, 355.49],
            # [-182.52, 352.99, 227.22],
            # [ -84.2,  434.5,  107.2],],
            #[[  -8.5, 455.3,   9.8],
            # [ 205.5, 319.5,-251.7],
            # [ 187.1,-353.0,-232.6],
            # [-262.7,-219.1, 318.7],
            # [-293.4,  -7.7, 360.2],
            # [-286.0,  93.2, 352.2],
            # [-182.7, 353.2, 227.6],
            # [ -84.2, 434.5, 107.2],],
        'delays':
            [0.000,-7.959, 7.602, 6.512, 3.755,-1.198, 4.103, 0.000],
            #[0.000,-7.959, 7.913, 6.512, 3.755,-1.198, 4.103, 0.000],
            #[-0.077,-8.065, 7.721, 6.315, 3.348,-1.317, 3.656, 0.],
        'offsets':
            [0., 0., 0., 0., 0., 0., 0., 0.],
        'amps':
            [2.08e-4,3.75e-5,3.69e-6,4.71e-5,4.21e-5,3.83e-5,4.09e-5,0.00e-5],
            #[3.95e-5,3.75e-5,4.07e-5,4.71e-5,4.21e-5,3.83e-5,4.09e-5,0.00e-5],
            #[3.92e-5,3.85e-5,4.27e-5,4.33e-5,3.76e-5,3.23e-5,3.59e-5,0.00e-5],
        'passbands': n.array([
[0.92119178272251157, 0.70497609872015965, 1.213526285569519, -1.4818472395827489, 5.7261552261104267, -2.949995608568341, 1.065070150093482, 2.9842814038554168, 1.020055815261081, -1.1386388014485318, 3.0543822393482918, 1.4548931649749526, -1.3614683369296627, 3.2394754402047674, -0.2104689321640455, 1.558789743003282, 0.33640002574916428, 1.7019925021202851, 0.65038791604530655, 0.68362881815210019, 2.2990169585786182, -1.2988081697133809, 3.7291631117304949, -1.9701750509709797, 3.3457765335522653, -0.51929454836969557, 0.17408396844198432, 0.15209545054936813, -0.43296126160353721, 0.79276982046468736, 1.0812217729759541, 1.9379225585315418]
            ] * 8),
        #'beam':
        #    fit.BeamPolynomial,
        #'bm_poly': n.reshape(n.array(
#[0.38498833804566684, 3.1197441443743701, -0.09752368829574562, 1.0044705135557901, -0.099607102048531765, 0.40921187810739423, -0.02377198874407551, 0.042187346121810541, 0.0010810336590857728, 0.0011102790518342056, -0.0044209110104365089, 0.0021193704071245036]
        #), (6,2)),
        #'beam': fit.Beam2DGaussian,
        #'bm_xwidth': .367,
        #'bm_ywidth': .656,
        'beam':
            fit.BeamAlm,
            #fit.BeamCosSeries,
        'bm_alm':
            n.array(
[-18.55897280530629, -27542306.881809086, 13.355325122272028, 4227285.8006816404, 9.274615715881616, 1.6944942968559635, -0.014257766911218547, 44.025360985589629, -4.1348664718693815, -0.63293571067042764, -1.5189981408132729, -1.3559241827949764, 0.12349580936589277, -0.046391400093972954, 0.012149256079961791, 0.065780634400298535, -0.069101512411171767, 0.028732562701692797, -0.029124954282416078, -0.010419275447542228, 0.15525304630143288, -0.016105345109623481, -0.083955971775234658, 0.029784988484923225, 0.11814866516176847, 0.02293464402673177, 0.068324806569361574, 0.076030935972810215, -0.037551555833373135, 0.076378821159718321, 0.029390457196374363, -0.14273740776548866, -0.046938518600600748, -0.081806904050731627, -0.029566989112598231, 0.066835144200714902, -0.030813042961359186, 0.0036055209844462564, -0.076904991524799515, 0.018918085072548826, 0.040696629593050218, 0.21293119303451069, -0.0020789808040208449, -0.11491415432032367, -0.019996098773143747, -0.093526210424694806, 0.080373375569747219, 0.019626566065013496, -0.13233995568166873, -0.11184785875788064, 0.034946652161371286, 0.24588209099372788, -0.0077954260770002476, -0.060888723258530841, 0.021138714567725484, -0.14556795969325437] + [0] * 38 * 2
#[-1.071782033802686, -6254.9473272861906, 3.772293955949916, 4605.141760226561, -0.69807799708790919, 1.3586158927235843, 0.11363362496685832, 0.34536529726415943, -1.0534869798870388, -0.29595659414765052, 1.0548774997448596, -1.143788481479729]
#[-0.94851587038680196, -9145.3882604947321, 3.3790738681717114, 5165.8934534180953, -0.65949384894628471, 1.3417703310073164, 0.23740646184447473, 0.15754239742328091, -0.89479494480788668, -0.68422852381955146, 1.281574239153022, -0.44891751544859504]
 #[-3.6010349378332611, 1034187853.9546268, 12.682040533598215, -15977951.605429912, -5.1025994500736171, 1.1392257450348189, -6.4735392680160322, -22778.229357919001, 0.072202655294914597, -0.27109881905256206, -0.035780491566443362, -2.7886388063191516, 1.0859326879991995, -9.9025806446069815, -0.6679717104179419, 0.076552920620834658, 1.6347996102926472, 0.73559455298476339, 1.532609531799761, 0.94033540142108096, -0.28992636827158808, -0.23335913317912732, 0.24668547396461687, -0.24326114955816242, 0.35214436437788077, 0.1214796414917966, -1.0094361521849331, -0.21612878628583759, 0.72795773794602203, -0.24849351394449354]
            ),
#        'bm_poly_cos': n.reshape(n.array(
#[0.65968159708756091, 0.0025659909518741548, -0.081980913499284686, 0.90728035623434633, 0.02456423992813269, -2.747905003776664e-05, 0.015322986798523949, 0.010411189187296912, 0.0091648541518815838, -0.0086706218280772681, -0.010574394631544205, -0.0095924018791234186, -0.016312220628520689, -0.015321155751978217, 0.011954722426508919]
##[3.6056588685016049, -1.0985150311609626, 0.72950214552853387, -0.67240929251070858, 0.0057798162496508678, -0.00025172922828870431, -0.014026449428520323, 0.001964023681328178]
##[0.93468215400054699, -0.27633475837818333, 0.14297389904812513, -0.15683062228205735, -0.0021171678213747656, -0.00033253224040971033, 0.00078485958958158944, 0.00046463969199212157]
#        #), (4,2)),
#        ), (3,5)),
#        'bm_poly_wid': n.array(
#[1.224669956265489, -0.15700065808426295, 0.00037337017315611438, -0.044154517182387547, -0.048436909946306235]
#        ),
    }
}

def get_freqs(sdf, sfreq, nchan):
    return n.arange(nchan, dtype=n.float) * sdf + sfreq

def lookup_key(loc_key):
    global locations
    if os.path.exists(loc_key): locations.update(eval(open(loc_key).read()))
    return locations[loc_key]

def get_aa(loc_key, sdf, sfreq, nchan, use_bp=True, use_ants=None):
    """Return an antenna array with the latest-greatest fit parameters for
    a given location.
        loc_key: The name of the antenna array.  Currently: 'pwa303','pgb371'
        sdf, sfreq, nchan: Their usual Miriad-defined meanings
        use_bp: Use bandpass information, or set to 1 (which is what you want
            if you've applied a bp calibration already).
        use_ants: A list of ant indices you want in the array if 
            you don't want all of them."""
    dat = lookup_key(loc_key)
    freqs = get_freqs(sdf, sfreq, nchan)
    beam = dat['beam'](freqs)
    beam.set_params(dat)
    location = dat['loc']
    antennas = []
    for pos, dly, off, amp, dec_bp in zip(dat['antpos'], dat['delays'], 
            dat['offsets'], dat['amps'], dat['passbands']):
        if not use_bp:
            amp = 1
            dec_bp = None
        antennas.append(
            fit.Antenna(pos[0],pos[1],pos[2], beam, delay=dly, offset=off,
                amp=amp, bp=dec_bp)
        )
    if not use_ants is None: antennas = [antennas[i] for i in use_ants]
    return fit.AntennaArray(antennas, dat['loc'])

def get_loc(loc_key):
    """Return an array location (with information about lat and long)."""
    return ant.ArrayLocation(lookup_key(loc_key)['loc'])
